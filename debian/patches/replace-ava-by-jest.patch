Description: replace ava by jest
 Generated by jest-codemods
Author: Xavier Guimard <yadd@debian.org>
Forwarded: not-needed
Last-Update: 2020-12-21

--- a/test.js
+++ b/test.js
@@ -1,15 +1,14 @@
-import stream from 'stream';
-import http from 'http';
-import test from 'ava';
-import createTestServer from 'create-test-server';
-import pify from 'pify';
-import pEvent from 'p-event';
-import mimicResponse from '.';
+const stream = require('stream');
+const http = require('http');
+const createTestServer = require('create-test-server');
+const pify = require('pify');
+const pEvent = require('p-event');
+const mimicResponse = require('.');
 
 const nodejsMajorVersion = process.versions.node.split('.')[0];
 let server;
 
-test.before(async () => {
+beforeAll(async () => {
 	server = await createTestServer();
 
 	server.get('/', (_request, response) => {
@@ -29,7 +28,11 @@
 	});
 });
 
-test('normal', async t => {
+afterAll(async () => {
+    await server.close();
+});
+
+test('normal', async () => {
 	const response = await pify(http.get, {errorFirst: false})(server.url);
 	response.unicorn = 'ðŸ¦„';
 	response.getContext = function () {
@@ -39,17 +42,17 @@
 	const toStream = new stream.PassThrough({autoDestroy: false});
 	mimicResponse(response, toStream);
 
-	t.is(toStream.statusCode, 200);
-	t.is(toStream.unicorn, 'ðŸ¦„');
-	t.is(toStream.getContext(), response.getContext());
+	expect(toStream.statusCode).toBe(200);
+	expect(toStream.unicorn).toBe('ðŸ¦„');
+	expect(toStream.getContext()).toBe(response.getContext());
 
 	response.resume();
 	await pEvent(response, 'end');
 
-	t.true(toStream.complete);
+	expect(toStream.complete).toBe(true);
 });
 
-test('do not overwrite prototype properties', async t => {
+test('do not overwrite prototype properties', async () => {
 	const response = await pify(http.get, {errorFirst: false})(server.url);
 	response.unicorn = 'ðŸ¦„';
 	response.getContext = function () {
@@ -64,21 +67,21 @@
 	const toStream = new stream.PassThrough({autoDestroy: false});
 	mimicResponse(response, toStream);
 
-	t.false(Object.keys(toStream).includes('on'));
-	t.is(toStream.statusCode, 200);
-	t.is(toStream.unicorn, 'ðŸ¦„');
-	t.is(toStream.getContext(), response.getContext());
-	t.false(toStream.complete);
+	expect(Object.keys(toStream).includes('on')).toBe(false);
+	expect(toStream.statusCode).toBe(200);
+	expect(toStream.unicorn).toBe('ðŸ¦„');
+	expect(toStream.getContext()).toBe(response.getContext());
+	expect(toStream.complete).toBe(false);
 
 	response.resume();
 	await pEvent(response, 'end');
 
 	await new Promise(resolve => setImmediate(resolve));
 
-	t.true(toStream.complete);
+	expect(toStream.complete).toBe(true);
 });
 
-test('`aborted` event', async t => {
+test('`aborted` event', async () => {
 	const response = await pify(http.get, {errorFirst: false})(`${server.url}/aborted`);
 
 	const toStream = new stream.PassThrough({autoDestroy: false});
@@ -86,30 +89,30 @@
 
 	await pEvent(toStream, 'aborted');
 
-	t.true(toStream.destroyed);
+	expect(toStream.destroyed).toBe(true);
 });
 
-test('autoDestroy must be false', async t => {
+test('autoDestroy must be false', async () => {
 	const response = await pify(http.get, {errorFirst: false})(`${server.url}/aborted`);
 
 	const toStream = new stream.PassThrough({autoDestroy: true});
 
-	t.throws(() => mimicResponse(response, toStream), {
+	expect(() => mimicResponse(response, toStream)).toThrowError({
 		message: 'The second stream must have the `autoDestroy` option set to `false`'
 	});
 });
 
-test('`close` event', async t => {
+test('`close` event', async () => {
 	{
 		const response = await pify(http.get, {errorFirst: false})(server.url);
 
 		const toStream = new stream.PassThrough({autoDestroy: false});
 		mimicResponse(response, toStream);
 
-		t.true(response.readable);
+		expect(response.readable).toBe(true);
 
 		if (nodejsMajorVersion > 11) {
-			t.false(response.readableEnded);
+			expect(response.readableEnded).toBe(false);
 		}
 
 		response.pipe(toStream);
@@ -117,12 +120,12 @@
 
 		await pEvent(toStream, 'close');
 
-		t.false(response.readable);
-		t.false(toStream.readable);
+		expect(response.readable).toBe(false);
+		expect(toStream.readable).toBe(false);
 
 		if (nodejsMajorVersion > 11) {
-			t.true(response.readableEnded);
-			t.true(toStream.readableEnded);
+			expect(response.readableEnded).toBe(true);
+			expect(toStream.readableEnded).toBe(true);
 		}
 	}
 
@@ -132,10 +135,10 @@
 		const toStream = new stream.PassThrough({autoDestroy: false});
 		mimicResponse(response, toStream);
 
-		t.true(response.readable);
+		expect(response.readable).toBe(true);
 
 		if (nodejsMajorVersion > 11) {
-			t.false(response.readableEnded);
+			expect(response.readableEnded).toBe(false);
 		}
 
 		response.pipe(toStream);
@@ -144,14 +147,14 @@
 		await pEvent(toStream, 'close');
 
 		if (nodejsMajorVersion < 12) {
-			t.false(response.readable);
-			t.true(toStream.readable);
+			expect(response.readable).toBe(false);
+			expect(toStream.readable).toBe(true);
 		} else if (nodejsMajorVersion < 13) {
-			t.true(response.readableEnded);
-			t.false(toStream.readableEnded);
+			expect(response.readableEnded).toBe(true);
+			expect(toStream.readableEnded).toBe(false);
 		} else {
-			t.false(response.readableEnded);
-			t.false(toStream.readableEnded);
+			expect(response.readableEnded).toBe(false);
+			expect(toStream.readableEnded).toBe(false);
 		}
 	}
 });
